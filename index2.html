<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Membrana Multiespecie: Dinámica de Lípidos</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020406; font-family: sans-serif; }
        #ui-overlay { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 10px; z-index: 10; }
        button { padding: 10px 18px; cursor: pointer; background: #111; color: #00ffcc; border: 1px solid #00ffcc; border-radius: 4px; font-weight: bold; }
        button:hover { background: #00ffcc; color: black; }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <button id="view-p">Perspectiva</button>
        <button id="view-f">Frontal</button>
        <button id="view-l">Lateral</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'lil-gui';

        // --- DEFINICIÓN DE ESPECIES ---
        const species = {
            'Lípido A (Cian)': { color: 0x00ffcc, stiffness: 0.18, elasticity: 0.08, boneLength: 0.6, gravity: 0.04 },
            'Lípido B (Magenta)': { color: 0xff00ff, stiffness: 0.05, elasticity: 0.02, boneLength: 0.9, gravity: 0.02 },
            'Lípido C (Amarillo)': { color: 0xffff00, stiffness: 0.40, elasticity: 0.15, boneLength: 0.3, gravity: 0.08 }
        };

        let currentType = 'Lípido A (Cian)';

        const params = {
            spacing: 1.7,
            drag: 0.93,
            layerGap: 2.5,
            segments: 4,
            mouseForce: 1.5,
            mouseRadius: 4.5,
            reset: () => init()
        };

        const SIZE = 18;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- INDICADOR VISUAL ---
        const mouseRing = new THREE.Mesh(
            new THREE.TorusGeometry(params.mouseRadius, 0.05, 16, 100),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
        );
        mouseRing.rotation.x = Math.PI / 2;
        scene.add(mouseRing);

        // --- UI ---
        const gui = new GUI();
        const fGlobal = gui.addFolder('Global');
        fGlobal.add(params, 'mouseForce', 0, 5).name('Fuerza Ratón');
        fGlobal.add(params, 'mouseRadius', 1, 10).name('Radio Ratón').onChange(v => mouseRing.scale.setScalar(v/4.5));
        fGlobal.add(params, 'reset').name('REINICIAR');

        const fSpecies = gui.addFolder('Editor de Especies');
        fSpecies.add({ type: currentType }, 'type', Object.keys(species)).name('Seleccionar Lípido').onChange(v => {
            currentType = v;
            refreshSpeciesUI();
        });

        let speciesControllers = [];
        function refreshSpeciesUI() {
            speciesControllers.forEach(c => c.destroy());
            speciesControllers = [];
            const s = species[currentType];
            speciesControllers.push(fSpecies.add(s, 'stiffness', 0.01, 0.5).name('Tensión Vert'));
            speciesControllers.push(fSpecies.add(s, 'elasticity', 0, 0.3).name('Tensión Lat'));
            speciesControllers.push(fSpecies.add(s, 'boneLength', 0.1, 1.5).name('Largo Cola'));
            speciesControllers.push(fSpecies.add(s, 'gravity', 0, 0.2).name('Gravedad'));
        }
        refreshSpeciesUI();

        // --- MALLAS E INSTANCIAS ---
        let headMeshes = {}, tailMeshes = {};
        let lipids = [];

        function init() {
            lipids.forEach(l => { scene.remove(l.hMesh); scene.remove(l.tMesh); });
            lipids = [];
            
            // Limpiar mallas anteriores
            Object.values(headMeshes).forEach(m => scene.remove(m));
            Object.values(tailMeshes).forEach(m => scene.remove(m));
            headMeshes = {}; tailMeshes = {};

            const headGeo = new THREE.SphereGeometry(0.4, 12, 8);
            const tailGeo = new THREE.CylinderGeometry(0.07, 0.04, 1, 6).rotateX(Math.PI / 2);

            // Crear una malla instanciada por cada especie
            Object.keys(species).forEach(key => {
                const count = (SIZE * SIZE * 2); 
                headMeshes[key] = new THREE.InstancedMesh(headGeo, new THREE.MeshPhongMaterial({color: species[key].color}), count);
                tailMeshes[key] = new THREE.InstancedMesh(tailGeo, new THREE.MeshPhongMaterial({color: 0x777777}), count * 6);
                scene.add(headMeshes[key], tailMeshes[key]);
            });

            const keys = Object.keys(species);
            for (let layer = 0; layer < 2; layer++) {
                const isTop = (layer === 0);
                for (let i = 0; i < SIZE; i++) {
                    for (let j = 0; j < SIZE; j++) {
                        // Asignar especie aleatoria
                        const type = keys[Math.floor(Math.random() * keys.length)];
                        const sParams = species[type];
                        
                        const x = (i - SIZE/2) * params.spacing;
                        const z = (j - SIZE/2) * params.spacing;
                        const y = isTop ? params.layerGap : -params.layerGap;

                        const lipid = { type, isTop, points: [], instanceIdx: i * SIZE + j + (layer * SIZE * SIZE) };
                        for(let s = 0; s <= params.segments; s++) {
                            const py = isTop ? y - (s * sParams.boneLength) : y + (s * sParams.boneLength);
                            lipid.points.push({
                                pos: new THREE.Vector3(x, py, z),
                                old: new THREE.Vector3(x, py, z),
                                origin: new THREE.Vector3(x, py, z),
                                acc: new THREE.Vector3(0, 0, 0)
                            });
                        }
                        lipids.push(lipid);
                    }
                }
            }
        }

        const mouseWorld = new THREE.Vector3(0, 0, 0);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        function physicsUpdate() {
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            raycaster.ray.intersectPlane(plane, mouseWorld);
            mouseRing.position.copy(mouseWorld);

            lipids.forEach(l => {
                const s = species[l.type];
                const head = l.points[0];
                
                // Dinámica basada en su propia especie
                const targetY = l.isTop ? params.layerGap : -params.layerGap;
                head.acc.y += (targetY - head.pos.y) * s.stiffness;
                head.acc.x += (head.origin.x - head.pos.x) * s.elasticity;
                head.acc.z += (head.origin.z - head.pos.z) * s.elasticity;
                
                const dist = head.pos.distanceTo(mouseWorld);
                if(dist < params.mouseRadius) {
                    const force = new THREE.Vector3().subVectors(head.pos, mouseWorld).normalize();
                    head.acc.add(force.multiplyScalar((1 - dist/params.mouseRadius) * params.mouseForce));
                }

                l.points.forEach((p, idx) => {
                    if(idx > 0) p.acc.y += s.gravity * (l.isTop ? -1 : 1);
                    const vel = new THREE.Vector3().subVectors(p.pos, p.old).multiplyScalar(params.drag);
                    p.old.copy(p.pos); p.pos.add(vel).add(p.acc); p.acc.set(0, 0, 0);
                });

                for(let n = 0; n < 3; n++) {
                    for(let i = 0; i < l.points.length - 1; i++) {
                        const p1 = l.points[i], p2 = l.points[i+1];
                        const diff = new THREE.Vector3().subVectors(p2.pos, p1.pos);
                        const err = (diff.length() - s.boneLength) / diff.length();
                        const corr = diff.multiplyScalar(err * 0.5);
                        if(i === 0) p2.pos.sub(corr.multiplyScalar(1.8));
                        else { p1.pos.add(corr); p2.pos.sub(corr); }
                    }
                }
            });
        }

        const dummy = new THREE.Object3D();
        const tailCounters = {};

        function render() {
            physicsUpdate();
            Object.keys(species).forEach(k => tailCounters[k] = 0);

            lipids.forEach((l) => {
                const hMesh = headMeshes[l.type];
                const tMesh = tailMeshes[l.type];
                
                dummy.position.copy(l.points[0].pos);
                dummy.rotation.set(0,0,0);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                hMesh.setMatrixAt(l.instanceIdx, dummy.matrix);

                for(let s = 0; s < params.segments; s++) {
                    const p1 = l.points[s].pos, p2 = l.points[s+1].pos;
                    dummy.position.copy(p1).add(p2).multiplyScalar(0.5);
                    dummy.lookAt(p2);
                    dummy.scale.set(1, 1, p1.distanceTo(p2));
                    dummy.updateMatrix();
                    tMesh.setMatrixAt(tailCounters[l.type]++, dummy.matrix);
                }
            });

            Object.keys(species).forEach(k => {
                headMeshes[k].instanceMatrix.needsUpdate = true;
                tailMeshes[k].instanceMatrix.needsUpdate = true;
            });
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        scene.add(new THREE.AmbientLight(0x444444));
        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(10, 20, 10);
        scene.add(light);

        const setCam = (x,y,z) => { camera.position.set(x,y,z); camera.lookAt(0,0,0); };
        document.getElementById('view-p').onclick = () => setCam(22, 18, 22);
        document.getElementById('view-f').onclick = () => setCam(0, 0, 40);
        document.getElementById('view-l').onclick = () => setCam(40, 0, 0);

        init();
        setCam(22, 18, 22);
        render();
    </script>
</body>
</html>