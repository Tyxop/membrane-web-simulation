<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hybrid Membrane: Index2 Visuals + Pro Features</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020406; font-family: sans-serif; }

        /* Index2 Button UI */
        #ui-overlay { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 10px; z-index: 10; }
        button { padding: 10px 18px; cursor: pointer; background: #111; color: #00ffcc; border: 1px solid #00ffcc; border-radius: 4px; font-weight: bold; }
        button:hover { background: #00ffcc; color: black; }

        /* Index Stats UI */
        #stats-panel {
            position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.85);
            padding: 15px; border-radius: 8px; border: 1px solid #444; color: white; width: 200px; pointer-events: none;
        }
        .bar-container { width: 100%; background: #222; height: 10px; margin: 5px 0 10px 0; }
        .bar { height: 100%; transition: width 0.1s; }

        /* External Elements UI */
        #elements-panel {
            position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.85);
            padding: 15px; border-radius: 8px; border: 1px solid #444; color: white; width: 220px;
        }
        #elements-panel h3 { margin: 0 0 10px 0; font-size: 12px; color: #aaa; text-transform: uppercase; }
        .element-btn {
            width: 100%; padding: 8px; margin: 5px 0; cursor: pointer;
            background: #222; color: #fff; border: 2px solid #444;
            border-radius: 4px; font-size: 11px; font-weight: bold;
            transition: all 0.2s;
        }
        .element-btn:hover { background: #333; }
        .element-btn.active { border-color: #00ffcc; background: #003333; color: #00ffcc; }
        .element-count { font-size: 10px; color: #888; margin-top: 10px; line-height: 1.6; }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <button id="view-p">Perspective</button>
        <button id="view-f">Front</button>
        <button id="view-l">Side</button>
    </div>

    <div id="elements-panel">
        <h3>Membrane Elements</h3>
        <button class="element-btn active" data-type="none">ðŸš« None (Navigate)</button>
        <button class="element-btn" data-type="transmembrane">ðŸ”´ Transmembrane Protein</button>
        <button class="element-btn" data-type="peripheral">ðŸŸ¡ Peripheral Protein</button>
        <button class="element-btn" data-type="cholesterol">âšª Cholesterol</button>
        <button class="element-btn" data-type="glycoprotein">ðŸŸ¢ Glycoprotein</button>
        <div class="element-count" id="element-count"></div>
        <div style="font-size: 9px; color: #666; margin-top: 12px; line-height: 1.4;">
            ðŸ’¡ Inside the circle: place elements<br>
            ðŸ’¡ Outside the circle: rotate camera<br>
            ðŸ’¡ Right-click: remove element
        </div>
    </div>

    <div id="stats-panel">
        <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">KINETIC ENERGY (REAL-TIME)</div>
        <div id="stats-content"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'lil-gui';

        // --- SPECIES DEFINITION ---
        // Using base values from Index2, but adding the 'energy' property from Index
        const species = {
            'Lipid A (Cyan)': { color: 0x00ffcc, stiffness: 0.18, elasticity: 0.08, boneLength: 0.6, gravity: 0.04, energy: 0 },
            'Lipid B (Magenta)': { color: 0xff00ff, stiffness: 0.05, elasticity: 0.02, boneLength: 0.9, gravity: 0.02, energy: 0 },
            'Lipid C (Yellow)': { color: 0xffff00, stiffness: 0.40, elasticity: 0.15, boneLength: 0.3, gravity: 0.08, energy: 0 }
        };

        let currentType = 'Lipid A (Cyan)';

        // --- EXTERNAL ELEMENTS DEFINITION ---
        const elementTypes = {
            transmembrane: {
                name: 'Transmembrane Protein',
                color: 0xff3333,
                geometry: 'cylinder', // Cylinder spanning the membrane
                radius: 1.5,          // Increased from 0.6 to 1.5 (thicker tube)
                height: 8,
                mass: 100.0,         // VERY HIGH MASS - nearly immobile
                createGlycan: false, // No carbohydrate chains
                strongInteraction: true, // Strong interaction enabled
                immobile: true       // Marked as immobile
            },
            peripheral: {
                name: 'Peripheral Protein',
                color: 0xffaa33,
                geometry: 'sphere', // Sphere on surface
                radius: 1.2,
                mass: 3.0,
                onSurface: true, // Attaches to the surface
                createGlycan: false
            },
            cholesterol: {
                name: 'Cholesterol',
                color: 0xcccccc,
                geometry: 'capsule', // Elongated shape between lipids
                radius: 0.25,
                height: 2.5,
                mass: 0.8,
                integrates: false // Integrates between lipids
            },
            glycoprotein: {
                name: 'Glycoprotein',
                color: 0x33ff33,
                geometry: 'cylinder',
                radius: 0.5,
                height: 8,
                mass: 4.5,
                createGlycan: true // Has carbohydrate chains
            }
        };

        let externalElements = [];
        let selectedElementType = 'none';
        let placementMode = false;

        // Combined parameters (Index2 + Temperature/Attraction from Index)
        // DENSITY AND INTERACTION IMPROVEMENTS:
        // - spacing reduced from 1.7 to 0.95 (lipids closer together, heads nearly touching)
        // - lipidRepulsion to avoid overlap while maintaining density
        // - Bidirectional interaction elements <-> lipids
        const params = {
            spacing: 0.95,        // Reduced for higher density
            drag: 0.93,
            layerGap: 2.5,
            segments: 4,
            mouseForce: 0.1,
            mouseRadius: 1.5,
            temperature: 0.02,
            attractionMode: false,
            lipidRepulsion: 0.8,  // New: prevents lipid overlap
            reset: () => init()
        };

        const SIZE = 18;
        const MEMBRANE_RADIUS = (SIZE / 2) * params.spacing * 1.2; // Radius of the membrane area

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
        document.body.appendChild(renderer.domElement);

        // --- CAMERA CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enabled = true; // Always enabled by default

        // --- VISUAL INDICATORS ---
        // Mouse ring for interaction
        const mouseRing = new THREE.Mesh(
            new THREE.TorusGeometry(params.mouseRadius, 0.05, 16, 100),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
        );
        mouseRing.rotation.x = Math.PI / 2;
        mouseRing.visible = false; // Hidden by default
        scene.add(mouseRing);

        // Circular membrane border (interactive area)
        const membraneBorder = new THREE.Mesh(
            new THREE.RingGeometry(MEMBRANE_RADIUS - 0.1, MEMBRANE_RADIUS + 0.1, 64),
            new THREE.MeshBasicMaterial({
                color: 0x00ffcc,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            })
        );
        membraneBorder.rotation.x = Math.PI / 2;
        membraneBorder.position.y = 0;
        membraneBorder.visible = false; // Hidden by default
        scene.add(membraneBorder);

        // --- UI (LIL-GUI) ---
        const gui = new GUI();
        const fGlobal = gui.addFolder('Global');
        fGlobal.add(params, 'temperature', 0, 0.3).name('Temperature (K)');
        fGlobal.add(params, 'mouseForce', 0, 5).name('Mouse Force');
        fGlobal.add(params, 'mouseRadius', 1, 10).name('Mouse Radius').onChange(v => mouseRing.scale.setScalar(v/4.5));
        fGlobal.add(params, 'attractionMode').name('Attraction Mode');
        fGlobal.add(params, 'lipidRepulsion', 0, 2).name('Lipid Repulsion');
        fGlobal.add(params, 'reset').name('RESET');

        const fSpecies = gui.addFolder('Species Editor');
        fSpecies.add({ type: currentType }, 'type', Object.keys(species)).name('Select Lipid').onChange(v => {
            currentType = v;
            refreshSpeciesUI();
        });

        let speciesControllers = [];
        function refreshSpeciesUI() {
            speciesControllers.forEach(c => c.destroy());
            speciesControllers = [];
            const s = species[currentType];
            speciesControllers.push(fSpecies.add(s, 'stiffness', 0.01, 0.5).name('Vert. Stiffness'));
            speciesControllers.push(fSpecies.add(s, 'elasticity', 0, 0.3).name('Lat. Elasticity'));
            speciesControllers.push(fSpecies.add(s, 'boneLength', 0.1, 1.5).name('Tail Length'));
            speciesControllers.push(fSpecies.add(s, 'gravity', 0, 0.2).name('Gravity'));
        }
        refreshSpeciesUI();

        // --- MESHES AND INSTANCES ---
        let headMeshes = {}, tailMeshes = {};
        let lipids = [];

        // --- EXTERNAL ELEMENT CREATION FUNCTIONS ---
        function createElementGeometry(type) {
            const def = elementTypes[type];
            let geo;

            switch(def.geometry) {
                case 'cylinder':
                    geo = new THREE.CylinderGeometry(def.radius, def.radius, def.height, 16);
                    break;
                case 'sphere':
                    geo = new THREE.SphereGeometry(def.radius, 16, 12);
                    break;
                case 'capsule':
                    // Capsule = cylinder + 2 hemispheres
                    const capsuleGeo = new THREE.CapsuleGeometry(def.radius, def.height - def.radius * 2, 8, 16);
                    geo = capsuleGeo;
                    break;
            }

            return geo;
        }

        function createElement(type, position, layer = 'top') {
            const def = elementTypes[type];
            const geo = createElementGeometry(type);
            const mat = new THREE.MeshPhongMaterial({
                color: def.color,
                shininess: 60,
                specular: 0x444444
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true; // Cast shadows
            mesh.receiveShadow = true; // Receive shadows

            // Position according to type
            if (def.onSurface) {
                // Peripheral protein: on the surface
                mesh.position.copy(position);
                mesh.position.y = layer === 'top' ? params.layerGap + def.radius : -params.layerGap - def.radius;
            } else if (def.integrates) {
                // Cholesterol: integrated between lipids
                mesh.position.copy(position);
                mesh.position.y = 0; // Centered in the membrane
            } else {
                // Transmembrane and glycoproteins: span the membrane
                mesh.position.copy(position);
                mesh.position.y = 0;
            }

            scene.add(mesh);

            // Create element with physics
            const element = {
                type: type,
                mesh: mesh,
                pos: mesh.position.clone(),
                old: mesh.position.clone(),
                acc: new THREE.Vector3(0, 0, 0),
                mass: def.mass,
                anchoredLipids: [], // Lipids this element is anchored to
                glycanChains: []
            };

            // If glycoprotein, create carbohydrate chains
            if (def.createGlycan) {
                createGlycanChains(element);
            }

            // Anchor to nearby lipids
            anchorToNearbyLipids(element, position);

            externalElements.push(element);
            updateElementCount();
            return element;
        }

        function createGlycanChains(element) {
            // Create 3-5 carbohydrate chains
            const numChains = 3 + Math.floor(Math.random() * 3);
            const def = elementTypes[element.type];

            for (let i = 0; i < numChains; i++) {
                const angle = (i / numChains) * Math.PI * 2;
                const offsetRadius = def.radius * 0.8;

                const chain = {
                    points: [],
                    color: 0x88ff88
                };

                // 4 segments per chain
                for (let s = 0; s < 4; s++) {
                    const segmentHeight = def.height / 2 + s * 0.8;
                    chain.points.push({
                        pos: new THREE.Vector3(
                            Math.cos(angle) * offsetRadius,
                            segmentHeight,
                            Math.sin(angle) * offsetRadius
                        ),
                        old: new THREE.Vector3(
                            Math.cos(angle) * offsetRadius,
                            segmentHeight,
                            Math.sin(angle) * offsetRadius
                        ),
                        acc: new THREE.Vector3(0, 0, 0)
                    });
                }

                element.glycanChains.push(chain);
            }
        }

        function anchorToNearbyLipids(element, position) {
            const def = elementTypes[element.type];
            // Anchor radius based on element size
            // Transmembrane proteins have a larger radius of influence
            const baseMultiplier = def.strongInteraction ? 4.5 : 3.5;
            const anchorRadius = def.radius * baseMultiplier;

            lipids.forEach((lipid, idx) => {
                const headPos = lipid.points[0].pos;
                const dist = headPos.distanceTo(position);

                if (dist < anchorRadius) {
                    element.anchoredLipids.push({
                        lipid: lipid,
                        lipidIndex: idx,
                        offset: new THREE.Vector3().subVectors(headPos, position),
                        distance: dist // Store initial distance for weight calculations
                    });
                    lipid.points[0].protein = element; // Mark lipid as anchored
                }
            });

            console.log(`Element ${def.name} anchored to ${element.anchoredLipids.length} lipids`);
        }

        function removeElement(element) {
            scene.remove(element.mesh);
            element.mesh.geometry.dispose();
            element.mesh.material.dispose();

            // Release anchored lipids
            element.anchoredLipids.forEach(anchor => {
                if (anchor.lipid.points[0].protein === element) {
                    anchor.lipid.points[0].protein = null;
                }
            });

            const idx = externalElements.indexOf(element);
            if (idx > -1) externalElements.splice(idx, 1);
            updateElementCount();
        }

        function updateElementCount() {
            const counts = {};
            Object.keys(elementTypes).forEach(k => counts[k] = 0);
            externalElements.forEach(e => counts[e.type]++);

            const lines = [];
            Object.keys(elementTypes).forEach(k => {
                if (counts[k] > 0) {
                    lines.push(`${elementTypes[k].name}: ${counts[k]}`);
                }
            });

            document.getElementById('element-count').innerHTML =
                lines.length > 0 ? lines.join('<br>') : 'No elements placed';
        }

        function init() {
            lipids.forEach(l => { scene.remove(l.hMesh); scene.remove(l.tMesh); });
            lipids = [];

            // Clear external elements
            externalElements.forEach(el => {
                scene.remove(el.mesh);
                el.mesh.geometry.dispose();
                el.mesh.material.dispose();
                // Clear glycan chains
                el.glycanChains.forEach(chain => {
                    if (chain.line) {
                        scene.remove(chain.line);
                        chain.line.geometry.dispose();
                    }
                    if (chain.spheres) {
                        chain.spheres.forEach(s => {
                            scene.remove(s);
                            s.geometry.dispose();
                            s.material.dispose();
                        });
                    }
                });
            });
            externalElements = [];

            Object.values(headMeshes).forEach(m => scene.remove(m));
            Object.values(tailMeshes).forEach(m => scene.remove(m));
            headMeshes = {}; tailMeshes = {};

            // Index2 geometries (the ones that looked better)
            const headGeo = new THREE.SphereGeometry(0.4, 12, 8);
            const tailGeo = new THREE.CylinderGeometry(0.07, 0.04, 1, 6).rotateX(Math.PI / 2);

            Object.keys(species).forEach(key => {
                const count = (SIZE * SIZE * 2);
                headMeshes[key] = new THREE.InstancedMesh(headGeo, new THREE.MeshPhongMaterial({color: species[key].color}), count);
                headMeshes[key].castShadow = true; // Cast shadows
                headMeshes[key].receiveShadow = true; // Receive shadows

                // Ensure enough space for segments
                tailMeshes[key] = new THREE.InstancedMesh(tailGeo, new THREE.MeshPhongMaterial({color: 0x777777}), count * (params.segments + 1));
                tailMeshes[key].castShadow = true; // Cast shadows
                tailMeshes[key].receiveShadow = true; // Receive shadows

                scene.add(headMeshes[key], tailMeshes[key]);
            });

            const keys = Object.keys(species);
            for (let layer = 0; layer < 2; layer++) {
                const isTop = (layer === 0);
                for (let i = 0; i < SIZE; i++) {
                    for (let j = 0; j < SIZE; j++) {
                        const type = keys[Math.floor(Math.random() * keys.length)];
                        const sParams = species[type];

                        const x = (i - SIZE/2) * params.spacing;
                        const z = (j - SIZE/2) * params.spacing;
                        const y = isTop ? params.layerGap : -params.layerGap;

                        const lipid = { type, isTop, points: [], instanceIdx: i * SIZE + j + (layer * SIZE * SIZE) };
                        for(let s = 0; s <= params.segments; s++) {
                            const py = isTop ? y - (s * sParams.boneLength) : y + (s * sParams.boneLength);
                            lipid.points.push({
                                pos: new THREE.Vector3(x, py, z),
                                old: new THREE.Vector3(x, py, z),                                protein: null, // Reference to the protein if this lipid is part of one

                                origin: new THREE.Vector3(x, py, z),
                                acc: new THREE.Vector3(0, 0, 0)
                            });
                        }
                        lipids.push(lipid);
                    }
                }
            }
            updateStatsDOM(); // Initialize stats UI
            updateElementCount(); // Initialize element counter
        }

        // --- UPDATE STATS DOM ---
        function updateStatsDOM() {
            const container = document.getElementById('stats-content');
            container.innerHTML = '';
            Object.keys(species).forEach(key => {
                const div = document.createElement('div');
                // Use hex colors for CSS
                const colorHex = '#' + species[key].color.toString(16).padStart(6, '0');
                div.innerHTML = `
                    <div style="display:flex; justify-content:space-between;">
                        <span style="color:${colorHex}; font-size:11px; font-weight:bold;">${key}</span>
                    </div>
                    <div class="bar-container">
                        <div id="bar-${key.replace(/\s/g, '-')}" class="bar" style="background-color:${colorHex}; width: 0%"></div>
                    </div>`;
                container.appendChild(div);
            });
        }

        const mouseWorld = new THREE.Vector3(0, 0, 0);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // --- DYNAMIC CURSOR BASED ON POSITION ---
            if (selectedElementType === 'none') {
                renderer.domElement.style.cursor = 'default';
                return;
            }

            // Calculate mouse position in world space
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const hoverPos = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, hoverPos);

            if (hoverPos) {
                const distFromCenter = Math.sqrt(hoverPos.x * hoverPos.x + hoverPos.z * hoverPos.z);

                if (distFromCenter <= MEMBRANE_RADIUS) {
                    renderer.domElement.style.cursor = 'crosshair'; // Inside - placement mode
                    membraneBorder.material.opacity = 0.35; // Highlight border
                } else {
                    renderer.domElement.style.cursor = 'grab'; // Outside - navigation mode
                    membraneBorder.material.opacity = 0.2; // Normal border
                }
            }
        });

        // --- CLICK SYSTEM TO PLACE ELEMENTS ---
        window.addEventListener('click', (e) => {
            // Detect if clicked on UI
            const clickedUI = e.target.closest('#elements-panel, #stats-panel, .lil-gui, #ui-overlay');
            if (clickedUI) return;

            // If no element selected, allow navigation
            if (selectedElementType === 'none') return;

            // Raycast to find position on membrane
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const clickPos = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, clickPos);

            if (clickPos) {
                // Check if click is within the membrane area
                const distanceFromCenter = Math.sqrt(clickPos.x * clickPos.x + clickPos.z * clickPos.z);

                if (distanceFromCenter <= MEMBRANE_RADIUS) {
                    // Click inside membrane - place element
                    const layer = camera.position.y > 0 ? 'top' : 'bottom';
                    createElement(selectedElementType, clickPos, layer);

                    // Visual feedback
                    membraneBorder.material.opacity = 0.4;
                    setTimeout(() => { membraneBorder.material.opacity = 0.2; }, 100);
                }
                // If outside, do nothing (OrbitControls handles camera)
            }
        });

        // Right-click to remove elements
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (selectedElementType === 'none') return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
                externalElements.map(el => el.mesh)
            );

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const element = externalElements.find(el => el.mesh === clickedMesh);
                if (element) {
                    removeElement(element);
                }
            }
        });

        // --- UI FOR SELECTING ELEMENTS ---
        document.querySelectorAll('.element-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.element-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedElementType = btn.getAttribute('data-type');

                // Show/hide visual indicators based on selection
                if (selectedElementType === 'none') {
                    // Navigation mode: hide all indicators
                    membraneBorder.visible = false;
                    mouseRing.visible = false;
                } else {
                    // Placement mode: show indicators
                    membraneBorder.visible = true;
                    mouseRing.visible = true;
                    membraneBorder.material.opacity = 0.25;
                }
            });
        });

        function physicsUpdate() {
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            raycaster.ray.intersectPlane(plane, mouseWorld);

            // Update visual ring
            mouseRing.position.copy(mouseWorld);
            mouseRing.material.color.set(params.attractionMode ? 0xff4444 : 0xffffff);

            // Reset accumulated energy
            Object.keys(species).forEach(k => species[k].energy = 0);

            lipids.forEach((l, idx) => {
                const s = species[l.type];
                const head = l.points[0];

                // 1. Thermal Vibration
                if(params.temperature > 0) {
                    head.acc.x += (Math.random() - 0.5) * params.temperature;
                    head.acc.y += (Math.random() - 0.5) * params.temperature;
                    head.acc.z += (Math.random() - 0.5) * params.temperature;
                }

                // 2. Spring Dynamics (reduced near immobile proteins)
                const targetY = l.isTop ? params.layerGap : -params.layerGap;
                head.acc.y += (targetY - head.pos.y) * s.stiffness;

                // Calculate elasticity factor based on proximity to immobile proteins
                let elasticityFactor = 1.0;
                externalElements.forEach(element => {
                    const def = elementTypes[element.type];
                    if (def.immobile) {
                        const distToProtein = head.pos.distanceTo(element.pos);
                        const influenceRadius = def.radius * 4.0;
                        if (distToProtein < influenceRadius) {
                            // Progressively reduce elasticity near the protein
                            const proximityFactor = distToProtein / influenceRadius;
                            elasticityFactor = Math.min(elasticityFactor, proximityFactor * 0.3);
                        }
                    }
                });

                head.acc.x += (head.origin.x - head.pos.x) * s.elasticity * elasticityFactor;
                head.acc.z += (head.origin.z - head.pos.z) * s.elasticity * elasticityFactor;

                // 3. Mouse Interaction
                const dist = head.pos.distanceTo(mouseWorld);
                if(dist < params.mouseRadius) {
                    const dir = new THREE.Vector3().subVectors(head.pos, mouseWorld).normalize();
                    const forceMag = (1 - dist/params.mouseRadius) * params.mouseForce;

                    if (params.attractionMode) {
                        head.acc.sub(dir.multiplyScalar(forceMag));
                    } else {
                        head.acc.add(dir.multiplyScalar(forceMag));
                    }
                }

                // 4. Repulsion between neighboring lipids (optimized - only nearby)
                if (params.lipidRepulsion > 0) {
                    // Only check lipids within a limited radius for optimization
                    const checkRadius = 2.0;
                    lipids.forEach((other, otherIdx) => {
                        if (idx < otherIdx && l.isTop === other.isTop) { // idx < otherIdx avoids duplicate checks
                            const otherHead = other.points[0].pos;
                            const diff = new THREE.Vector3().subVectors(head.pos, otherHead);
                            const distance = diff.length();

                            if (distance < checkRadius) {
                                const minDist = 0.82; // Minimum distance (nearly touching)

                                if (distance < minDist && distance > 0.01) {
                                    const repulsionForce = ((minDist - distance) / minDist) * params.lipidRepulsion;
                                    const force = diff.normalize().multiplyScalar(repulsionForce);
                                    head.acc.add(force);
                                    other.points[0].acc.sub(force); // Apply opposite force to the other lipid
                                }
                            }
                        }
                    });
                }

                // 5. Interaction with external elements (improved - greater impact)
                externalElements.forEach(element => {
                    const elemPos = element.pos;
                    const distToElem = head.pos.distanceTo(elemPos);
                    const def = elementTypes[element.type];

                    // Transmembrane proteins have a larger interaction radius
                    const interactionMultiplier = def.strongInteraction ? 3.5 : 2.5;
                    const interactionRadius = def.radius * interactionMultiplier;

                    if (distToElem < interactionRadius) {
                        // IMMOBILE PROTEINS: Repulsion only, no attraction
                        if (def.immobile) {
                            // Very strong repulsion - protein pushes lipids away
                            const repelDir = new THREE.Vector3().subVectors(head.pos, elemPos);
                            repelDir.y = 0; // Lateral only

                            // Expanded repulsion radius for immobile proteins
                            const repulsionRadius = def.radius * 2.5;
                            if (distToElem < repulsionRadius) {
                                const baseRepulsion = 4.5; // Very strong
                                const repelForce = (1 - distToElem / repulsionRadius) * baseRepulsion;
                                head.acc.add(repelDir.normalize().multiplyScalar(repelForce));
                            }
                        } else {
                            // MOBILE PROTEINS: Normal behavior with attraction
                            const isAnchored = element.anchoredLipids.some(a => a.lipid === l);

                            if (isAnchored) {
                                // Attraction force toward protein
                                const attractDir = new THREE.Vector3().subVectors(elemPos, head.pos);
                                attractDir.y = 0; // Lateral only
                                const attractStrength = def.strongInteraction ? 0.08 : 0.05;
                                const attractForce = (distToElem / interactionRadius) * attractStrength;
                                head.acc.add(attractDir.normalize().multiplyScalar(attractForce));
                            } else if (distToElem < def.radius * 2.0) {
                                // Repulsion if very close but not anchored
                                const repelDir = new THREE.Vector3().subVectors(head.pos, elemPos);
                                repelDir.y = 0; // Lateral only
                                const baseRepulsion = def.strongInteraction ? 3.5 : 0.4;
                                const repelForce = (1 - distToElem / (def.radius * 2.0)) * baseRepulsion;
                                head.acc.add(repelDir.normalize().multiplyScalar(repelForce));
                            }
                        }
                    }
                });

                // 4. Verlet Integration + Energy Calculation
                l.points.forEach((p, idx) => {
                    if(idx > 0) p.acc.y += s.gravity * (l.isTop ? -1 : 1);

                    const vel = new THREE.Vector3().subVectors(p.pos, p.old);

                    // Accumulate kinetic energy for stats
                    s.energy += vel.length();

                    vel.multiplyScalar(params.drag);
                    p.old.copy(p.pos);
                    p.pos.add(vel).add(p.acc);
                    p.acc.set(0, 0, 0);
                });

                // 5. Tail Constraints (Index2 Logic)
                for(let n = 0; n < 3; n++) {
                    for(let i = 0; i < l.points.length - 1; i++) {
                        const p1 = l.points[i], p2 = l.points[i+1];
                        const diff = new THREE.Vector3().subVectors(p2.pos, p1.pos);
                        const currentLen = diff.length();
                        const err = (currentLen - s.boneLength) / currentLen;
                        const corr = diff.multiplyScalar(err * 0.5);

                        if(i === 0) p2.pos.sub(corr.multiplyScalar(1.8)); // Head fixed, tail moves more
                        else { p1.pos.add(corr); p2.pos.sub(corr); }
                    }
                }
            });

            // Update UI Bars
            Object.keys(species).forEach(k => {
                const barId = `bar-${k.replace(/\s/g, '-')}`;
                const el = document.getElementById(barId);
                if(el) {
                    // Visual scale factor so the bar looks good
                    const width = Math.min(species[k].energy * 0.5, 100);
                    el.style.width = width + '%';
                }
            });

            // --- EXTERNAL ELEMENT PHYSICS ---
            externalElements.forEach(element => {
                const def = elementTypes[element.type];

                // If immobile, only update mesh position and skip physics
                if (def.immobile) {
                    element.mesh.position.copy(element.pos);
                    return;
                }

                // 1. Calculate average position of anchored lipids (improved)
                if (element.anchoredLipids.length > 0) {
                    const avgPos = new THREE.Vector3(0, 0, 0);
                    let totalWeight = 0;

                    element.anchoredLipids.forEach(anchor => {
                        const lipidPos = anchor.lipid.points[0].pos;
                        const distance = lipidPos.distanceTo(element.pos);
                        // Weight based on distance - closer lipids have more influence
                        const weight = 1.0 / (distance + 0.5);
                        avgPos.add(lipidPos.clone().multiplyScalar(weight));
                        totalWeight += weight;
                    });

                    if (totalWeight > 0) {
                        avgPos.divideScalar(totalWeight);

                        // Apply force toward average position (stronger elastic anchoring)
                        const anchorForce = new THREE.Vector3().subVectors(avgPos, element.pos);
                        anchorForce.y = 0; // Lateral movement only
                        element.acc.add(anchorForce.multiplyScalar(0.25)); // Increased from 0.1 to 0.25
                    }

                    // Apply forces from individually anchored lipids
                    element.anchoredLipids.forEach(anchor => {
                        const lipid = anchor.lipid;
                        const lipidVel = new THREE.Vector3().subVectors(
                            lipid.points[0].pos,
                            lipid.points[0].old
                        );
                        // Element inherits part of the lipid movement
                        element.acc.add(lipidVel.multiplyScalar(0.05));
                    });
                }

                // 2. Additional inertia by mass
                const massEffect = 1.0 - (def.mass * 0.05);

                // 3. Friction with the membrane
                const vel = new THREE.Vector3().subVectors(element.pos, element.old);
                vel.multiplyScalar(0.88 * massEffect); // Variable friction based on mass

                // 4. Verlet Integration
                element.old.copy(element.pos);
                element.pos.add(vel).add(element.acc);
                element.acc.set(0, 0, 0);

                // 5. Update mesh position
                element.mesh.position.copy(element.pos);

                // 6. Smooth rotation based on movement (new - for realism)
                if (vel.length() > 0.01) {
                    const currentRotation = element.mesh.rotation.y;
                    const targetRotation = Math.atan2(vel.x, vel.z);
                    element.mesh.rotation.y = THREE.MathUtils.lerp(currentRotation, targetRotation, 0.1);
                }

                // 5. Glycan chain physics
                if (element.glycanChains.length > 0) {
                    element.glycanChains.forEach(chain => {
                        chain.points.forEach((p, idx) => {
                            if (idx === 0) {
                                // First point anchored to element
                                const localPos = chain.points[0].pos.clone();
                                p.pos.copy(element.pos).add(localPos);
                                p.old.copy(p.pos);
                            } else {
                                // Light upward gravity (buoyancy)
                                p.acc.y += 0.01;

                                // Thermal vibration
                                if (params.temperature > 0) {
                                    p.acc.x += (Math.random() - 0.5) * params.temperature * 2;
                                    p.acc.z += (Math.random() - 0.5) * params.temperature * 2;
                                }

                                // Integration
                                const chainVel = new THREE.Vector3().subVectors(p.pos, p.old);
                                chainVel.multiplyScalar(0.9);
                                p.old.copy(p.pos);
                                p.pos.add(chainVel).add(p.acc);
                                p.acc.set(0, 0, 0);
                            }
                        });

                        // Distance constraints between segments
                        for (let iter = 0; iter < 2; iter++) {
                            for (let i = 0; i < chain.points.length - 1; i++) {
                                const p1 = chain.points[i];
                                const p2 = chain.points[i + 1];
                                const diff = new THREE.Vector3().subVectors(p2.pos, p1.pos);
                                const dist = diff.length();
                                const targetDist = 0.6;
                                const error = (dist - targetDist) / dist;
                                const correction = diff.multiplyScalar(error * 0.5);

                                if (i === 0) {
                                    p2.pos.sub(correction);
                                } else {
                                    p1.pos.add(correction);
                                    p2.pos.sub(correction);
                                }
                            }
                        }
                    });
                }

            });
        }

        const dummy = new THREE.Object3D();
        const tailCounters = {};

        // Geometry and material for glycans
        let glycanLineMaterial, glycanSphereGeo, glycanSphereMat;

        function render() {
            physicsUpdate();
            controls.update(); // Update OrbitControls

            Object.keys(species).forEach(k => tailCounters[k] = 0);

            lipids.forEach((l) => {
                const hMesh = headMeshes[l.type];
                const tMesh = tailMeshes[l.type];

                // Render Head
                dummy.position.copy(l.points[0].pos);
                dummy.rotation.set(0,0,0);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                hMesh.setMatrixAt(l.instanceIdx, dummy.matrix);

                // Render Tail (Index2 Style)
                for(let s = 0; s < params.segments; s++) {
                    const p1 = l.points[s].pos, p2 = l.points[s+1].pos;
                    dummy.position.copy(p1).add(p2).multiplyScalar(0.5);
                    dummy.lookAt(p2);
                    // Scale the cylinder to perfectly connect the points (Index2 look)
                    dummy.scale.set(1, 1, p1.distanceTo(p2));
                    dummy.updateMatrix();
                    tMesh.setMatrixAt(tailCounters[l.type]++, dummy.matrix);
                }
            });

            Object.keys(species).forEach(k => {
                headMeshes[k].instanceMatrix.needsUpdate = true;
                tailMeshes[k].instanceMatrix.needsUpdate = true;
            });

            // Render glycan chains
            externalElements.forEach(element => {
                element.glycanChains.forEach(chain => {
                    // Remove previous lines if they exist
                    if (chain.line) {
                        scene.remove(chain.line);
                        chain.line.geometry.dispose();
                    }
                    if (chain.spheres) {
                        chain.spheres.forEach(s => {
                            scene.remove(s);
                            s.geometry.dispose();
                            s.material.dispose();
                        });
                    }

                    // Create lines connecting the points
                    const points = chain.points.map(p => p.pos);
                    const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                    if (!glycanLineMaterial) {
                        glycanLineMaterial = new THREE.LineBasicMaterial({ color: 0x88ff88, linewidth: 2 });
                    }
                    chain.line = new THREE.Line(lineGeo, glycanLineMaterial);
                    scene.add(chain.line);

                    // Create spheres at each point
                    chain.spheres = [];
                    if (!glycanSphereGeo) {
                        glycanSphereGeo = new THREE.SphereGeometry(0.15, 8, 6);
                        glycanSphereMat = new THREE.MeshPhongMaterial({ color: 0x88ff88 });
                    }
                    chain.points.forEach(p => {
                        const sphere = new THREE.Mesh(glycanSphereGeo, glycanSphereMat);
                        sphere.position.copy(p.pos);
                        scene.add(sphere);
                        chain.spheres.push(sphere);
                    });
                });
            });

            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        // --- LIGHTING AND SHADOWS ---
        scene.add(new THREE.AmbientLight(0x444444, 1.0)); // Ambient light for base illumination

        const light = new THREE.DirectionalLight(0xffffff, 2.5); // More intense directional light
        light.position.set(10, 20, 10);
        light.castShadow = true; // Cast shadows

        // High quality shadow configuration
        light.shadow.mapSize.width = 2048; // Higher resolution for sharper shadows
        light.shadow.mapSize.height = 2048;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 50;
        light.shadow.camera.left = -25;
        light.shadow.camera.right = 25;
        light.shadow.camera.top = 25;
        light.shadow.camera.bottom = -25;
        light.shadow.bias = -0.0001; // Reduce shadow artifacts

        scene.add(light);

        // Background plane to receive shadows (simulates ambient occlusion)
        const planeGeo = new THREE.PlaneGeometry(60, 60);
        const planeMat = new THREE.ShadowMaterial({ opacity: 0.3 }); // Material that only shows shadows
        const groundPlane = new THREE.Mesh(planeGeo, planeMat);
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.position.y = -5; // Below the membrane
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);

        // Camera Functions (now compatible with OrbitControls)
        const setCam = (x,y,z) => {
            camera.position.set(x,y,z);
            controls.target.set(0,0,0);
            controls.update();
        };
        document.getElementById('view-p').onclick = () => setCam(22, 18, 22);
        document.getElementById('view-f').onclick = () => setCam(0, 0, 40);
        document.getElementById('view-l').onclick = () => setCam(40, 0, 0);

        init();
        setCam(22, 18, 22);
        render();
    </script>
</body>
</html>
