<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Membrana H√≠brida: Visuales Index2 + Funciones Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020406; font-family: sans-serif; }
        
        /* UI de Botones de Index2 */
        #ui-overlay { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 10px; z-index: 10; }
        button { padding: 10px 18px; cursor: pointer; background: #111; color: #00ffcc; border: 1px solid #00ffcc; border-radius: 4px; font-weight: bold; }
        button:hover { background: #00ffcc; color: black; }

        /* UI de Estad√≠sticas de Index */
        #stats-panel {
            position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.85);
            padding: 15px; border-radius: 8px; border: 1px solid #444; color: white; width: 200px; pointer-events: none;
        }
        .bar-container { width: 100%; background: #222; height: 10px; margin: 5px 0 10px 0; }
        .bar { height: 100%; transition: width 0.1s; }

        /* UI de Elementos Externos */
        #elements-panel {
            position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.85);
            padding: 15px; border-radius: 8px; border: 1px solid #444; color: white; width: 220px;
        }
        #elements-panel h3 { margin: 0 0 10px 0; font-size: 12px; color: #aaa; text-transform: uppercase; }
        .element-btn {
            width: 100%; padding: 8px; margin: 5px 0; cursor: pointer;
            background: #222; color: #fff; border: 2px solid #444;
            border-radius: 4px; font-size: 11px; font-weight: bold;
            transition: all 0.2s;
        }
        .element-btn:hover { background: #333; }
        .element-btn.active { border-color: #00ffcc; background: #003333; color: #00ffcc; }
        .element-count { font-size: 10px; color: #888; margin-top: 10px; line-height: 1.6; }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <button id="view-p">Perspectiva</button>
        <button id="view-f">Frontal</button>
        <button id="view-l">Lateral</button>
    </div>

    <div id="elements-panel">
        <h3>Elementos de Membrana</h3>
        <button class="element-btn active" data-type="none">üö´ Ninguno (Navegar)</button>
        <button class="element-btn" data-type="transmembrane">üî¥ Prote√≠na Transmembrana</button>
        <button class="element-btn" data-type="peripheral">üü° Prote√≠na Perif√©rica</button>
        <button class="element-btn" data-type="cholesterol">‚ö™ Colesterol</button>
        <button class="element-btn" data-type="glycoprotein">üü¢ Glicoprote√≠na</button>
        <div class="element-count" id="element-count"></div>
        <div style="font-size: 9px; color: #666; margin-top: 12px; line-height: 1.4;">
            üí° Dentro del c√≠rculo: colocar elementos<br>
            üí° Fuera del c√≠rculo: rotar c√°mara<br>
            üí° Click derecho: eliminar elemento
        </div>
    </div>

    <div id="stats-panel">
        <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">ENERG√çA CIN√âTICA (TIEMPO REAL)</div>
        <div id="stats-content"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'lil-gui';

        // --- DEFINICI√ìN DE ESPECIES ---
        // Usamos los valores base de Index2, pero a√±adimos la propiedad 'energy' de Index
        const species = {
            'L√≠pido A (Cian)': { color: 0x00ffcc, stiffness: 0.18, elasticity: 0.08, boneLength: 0.6, gravity: 0.04, energy: 0 },
            'L√≠pido B (Magenta)': { color: 0xff00ff, stiffness: 0.05, elasticity: 0.02, boneLength: 0.9, gravity: 0.02, energy: 0 },
            'L√≠pido C (Amarillo)': { color: 0xffff00, stiffness: 0.40, elasticity: 0.15, boneLength: 0.3, gravity: 0.08, energy: 0 }
        };

        let currentType = 'L√≠pido A (Cian)';

        // --- DEFINICI√ìN DE ELEMENTOS EXTERNOS ---
        const elementTypes = {
            transmembrane: {
                name: 'Prote√≠na Transmembrana',
                color: 0xff3333,
                geometry: 'cylinder', // Cilindro que atraviesa la membrana
                radius: 1.5,          // Aumentado de 0.6 a 1.5 (tubo m√°s grueso)
                height: 8,
                mass: 100.0,         // MASA MUY ALTA - casi inm√≥vil
                createGlycan: false, // Sin cadenas de carbohidratos
                strongInteraction: true, // Interacci√≥n fuerte activada
                immobile: true       // Marca como inm√≥vil
            },
            peripheral: {
                name: 'Prote√≠na Perif√©rica',
                color: 0xffaa33,
                geometry: 'sphere', // Esfera en superficie
                radius: 1.2,
                mass: 3.0,
                onSurface: true, // Se adhiere a la superficie
                createGlycan: false
            },
            cholesterol: {
                name: 'Colesterol',
                color: 0xcccccc,
                geometry: 'capsule', // Forma alargada entre l√≠pidos
                radius: 0.25,
                height: 2.5,
                mass: 0.8,
                integrates: false // Se integra entre l√≠pidos
            },
            glycoprotein: {
                name: 'Glicoprote√≠na',
                color: 0x33ff33,
                geometry: 'cylinder',
                radius: 0.5,
                height: 8,
                mass: 4.5,
                createGlycan: true // Tiene cadenas de carbohidratos
            }
        };

        let externalElements = [];
        let selectedElementType = 'none';
        let placementMode = false;

        // Par√°metros combinados (Index2 + Temperatura/Atracci√≥n de Index)
        // MEJORAS DE DENSIDAD E INTERACCI√ìN:
        // - spacing reducido de 1.7 a 0.95 (l√≠pidos m√°s juntos, cabezas casi pegadas)
        // - lipidRepulsion para evitar solapamiento manteniendo densidad
        // - Interacci√≥n bidireccional elementos ‚Üî l√≠pidos
        const params = {
            spacing: 0.95,        // Reducido para mayor densidad
            drag: 0.93,
            layerGap: 2.5,
            segments: 4,
            mouseForce: 0.1,
            mouseRadius: 1.5,
            temperature: 0.02,
            attractionMode: false,
            lipidRepulsion: 0.8,  // Nueva: evita solapamiento entre l√≠pidos
            reset: () => init()
        };

        const SIZE = 18;
        const MEMBRANE_RADIUS = (SIZE / 2) * params.spacing * 1.2; // Radio del √°rea de la membrana

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Activar sombras
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves
        document.body.appendChild(renderer.domElement);

        // --- CONTROLES DE C√ÅMARA ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enabled = true; // Siempre habilitado por defecto

        // --- INDICADORES VISUALES ---
        // Anillo del rat√≥n para interacci√≥n
        const mouseRing = new THREE.Mesh(
            new THREE.TorusGeometry(params.mouseRadius, 0.05, 16, 100),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
        );
        mouseRing.rotation.x = Math.PI / 2;
        mouseRing.visible = false; // Oculto por defecto
        scene.add(mouseRing);

        // Borde circular de la membrana (√°rea interactiva)
        const membraneBorder = new THREE.Mesh(
            new THREE.RingGeometry(MEMBRANE_RADIUS - 0.1, MEMBRANE_RADIUS + 0.1, 64),
            new THREE.MeshBasicMaterial({
                color: 0x00ffcc,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            })
        );
        membraneBorder.rotation.x = Math.PI / 2;
        membraneBorder.position.y = 0;
        membraneBorder.visible = false; // Oculto por defecto
        scene.add(membraneBorder);

        // --- UI (LIL-GUI) ---
        const gui = new GUI();
        const fGlobal = gui.addFolder('Global');
        fGlobal.add(params, 'temperature', 0, 0.3).name('Temperatura (K)');
        fGlobal.add(params, 'mouseForce', 0, 5).name('Fuerza Rat√≥n');
        fGlobal.add(params, 'mouseRadius', 1, 10).name('Radio Rat√≥n').onChange(v => mouseRing.scale.setScalar(v/4.5));
        fGlobal.add(params, 'attractionMode').name('Modo Succi√≥n');
        fGlobal.add(params, 'lipidRepulsion', 0, 2).name('Repulsi√≥n L√≠pidos');
        fGlobal.add(params, 'reset').name('REINICIAR');

        const fSpecies = gui.addFolder('Editor de Especies');
        fSpecies.add({ type: currentType }, 'type', Object.keys(species)).name('Seleccionar L√≠pido').onChange(v => {
            currentType = v;
            refreshSpeciesUI();
        });

        let speciesControllers = [];
        function refreshSpeciesUI() {
            speciesControllers.forEach(c => c.destroy());
            speciesControllers = [];
            const s = species[currentType];
            speciesControllers.push(fSpecies.add(s, 'stiffness', 0.01, 0.5).name('Tensi√≥n Vert'));
            speciesControllers.push(fSpecies.add(s, 'elasticity', 0, 0.3).name('Tensi√≥n Lat'));
            speciesControllers.push(fSpecies.add(s, 'boneLength', 0.1, 1.5).name('Largo Cola'));
            speciesControllers.push(fSpecies.add(s, 'gravity', 0, 0.2).name('Gravedad'));
        }
        refreshSpeciesUI();

        // --- MALLAS E INSTANCIAS ---
        let headMeshes = {}, tailMeshes = {};
        let lipids = [];

        // --- FUNCIONES DE CREACI√ìN DE ELEMENTOS EXTERNOS ---
        function createElementGeometry(type) {
            const def = elementTypes[type];
            let geo;

            switch(def.geometry) {
                case 'cylinder':
                    geo = new THREE.CylinderGeometry(def.radius, def.radius, def.height, 16);
                    break;
                case 'sphere':
                    geo = new THREE.SphereGeometry(def.radius, 16, 12);
                    break;
                case 'capsule':
                    // C√°psula = cilindro + 2 hemisferios
                    const capsuleGeo = new THREE.CapsuleGeometry(def.radius, def.height - def.radius * 2, 8, 16);
                    geo = capsuleGeo;
                    break;
            }

            return geo;
        }

        function createElement(type, position, layer = 'top') {
            const def = elementTypes[type];
            const geo = createElementGeometry(type);
            const mat = new THREE.MeshPhongMaterial({
                color: def.color,
                shininess: 60,
                specular: 0x444444
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true; // Proyectar sombras
            mesh.receiveShadow = true; // Recibir sombras

            // Posicionar seg√∫n el tipo
            if (def.onSurface) {
                // Prote√≠na perif√©rica: en la superficie
                mesh.position.copy(position);
                mesh.position.y = layer === 'top' ? params.layerGap + def.radius : -params.layerGap - def.radius;
            } else if (def.integrates) {
                // Colesterol: integrado entre l√≠pidos
                mesh.position.copy(position);
                mesh.position.y = 0; // Centrado en la membrana
            } else {
                // Transmembrana y glicoprote√≠nas: atraviesan la membrana
                mesh.position.copy(position);
                mesh.position.y = 0;
            }

            scene.add(mesh);

            // Crear elemento con f√≠sica
            const element = {
                type: type,
                mesh: mesh,
                pos: mesh.position.clone(),
                old: mesh.position.clone(),
                acc: new THREE.Vector3(0, 0, 0),
                mass: def.mass,
                anchoredLipids: [], // L√≠pidos a los que est√° anclado
                glycanChains: []
            };

            // Si es glicoprote√≠na, crear cadenas de carbohidratos
            if (def.createGlycan) {
                createGlycanChains(element);
            }

            // Anclar a l√≠pidos cercanos
            anchorToNearbyLipids(element, position);

            externalElements.push(element);
            updateElementCount();
            return element;
        }

        function createGlycanChains(element) {
            // Crear 3-5 cadenas de carbohidratos
            const numChains = 3 + Math.floor(Math.random() * 3);
            const def = elementTypes[element.type];

            for (let i = 0; i < numChains; i++) {
                const angle = (i / numChains) * Math.PI * 2;
                const offsetRadius = def.radius * 0.8;

                const chain = {
                    points: [],
                    color: 0x88ff88
                };

                // 4 segmentos por cadena
                for (let s = 0; s < 4; s++) {
                    const segmentHeight = def.height / 2 + s * 0.8;
                    chain.points.push({
                        pos: new THREE.Vector3(
                            Math.cos(angle) * offsetRadius,
                            segmentHeight,
                            Math.sin(angle) * offsetRadius
                        ),
                        old: new THREE.Vector3(
                            Math.cos(angle) * offsetRadius,
                            segmentHeight,
                            Math.sin(angle) * offsetRadius
                        ),
                        acc: new THREE.Vector3(0, 0, 0)
                    });
                }

                element.glycanChains.push(chain);
            }
        }

        function anchorToNearbyLipids(element, position) {
            const def = elementTypes[element.type];
            // Radio de anclaje basado en el tama√±o del elemento
            // Prote√≠nas transmembrana tienen mayor radio de influencia
            const baseMultiplier = def.strongInteraction ? 4.5 : 3.5;
            const anchorRadius = def.radius * baseMultiplier;

            lipids.forEach((lipid, idx) => {
                const headPos = lipid.points[0].pos;
                const dist = headPos.distanceTo(position);

                if (dist < anchorRadius) {
                    element.anchoredLipids.push({
                        lipid: lipid,
                        lipidIndex: idx,
                        offset: new THREE.Vector3().subVectors(headPos, position),
                        distance: dist // Guardar distancia inicial para c√°lculos de peso
                    });
                    lipid.points[0].protein = element; // Marcar l√≠pido como anclado
                }
            });

            console.log(`Elemento ${def.name} anclado a ${element.anchoredLipids.length} l√≠pidos`);
        }

        function removeElement(element) {
            scene.remove(element.mesh);
            element.mesh.geometry.dispose();
            element.mesh.material.dispose();

            // Liberar l√≠pidos anclados
            element.anchoredLipids.forEach(anchor => {
                if (anchor.lipid.points[0].protein === element) {
                    anchor.lipid.points[0].protein = null;
                }
            });

            const idx = externalElements.indexOf(element);
            if (idx > -1) externalElements.splice(idx, 1);
            updateElementCount();
        }

        function updateElementCount() {
            const counts = {};
            Object.keys(elementTypes).forEach(k => counts[k] = 0);
            externalElements.forEach(e => counts[e.type]++);

            const lines = [];
            Object.keys(elementTypes).forEach(k => {
                if (counts[k] > 0) {
                    lines.push(`${elementTypes[k].name}: ${counts[k]}`);
                }
            });

            document.getElementById('element-count').innerHTML =
                lines.length > 0 ? lines.join('<br>') : 'Ning√∫n elemento colocado';
        }

        function init() {
            lipids.forEach(l => { scene.remove(l.hMesh); scene.remove(l.tMesh); });
            lipids = [];

            // Limpiar elementos externos
            externalElements.forEach(el => {
                scene.remove(el.mesh);
                el.mesh.geometry.dispose();
                el.mesh.material.dispose();
                // Limpiar cadenas de glicanos
                el.glycanChains.forEach(chain => {
                    if (chain.line) {
                        scene.remove(chain.line);
                        chain.line.geometry.dispose();
                    }
                    if (chain.spheres) {
                        chain.spheres.forEach(s => {
                            scene.remove(s);
                            s.geometry.dispose();
                            s.material.dispose();
                        });
                    }
                });
            });
            externalElements = [];

            Object.values(headMeshes).forEach(m => scene.remove(m));
            Object.values(tailMeshes).forEach(m => scene.remove(m));
            headMeshes = {}; tailMeshes = {};

            // Geometr√≠as de Index2 (las que te gustaban m√°s)
            const headGeo = new THREE.SphereGeometry(0.4, 12, 8);
            const tailGeo = new THREE.CylinderGeometry(0.07, 0.04, 1, 6).rotateX(Math.PI / 2);

            Object.keys(species).forEach(key => {
                const count = (SIZE * SIZE * 2);
                headMeshes[key] = new THREE.InstancedMesh(headGeo, new THREE.MeshPhongMaterial({color: species[key].color}), count);
                headMeshes[key].castShadow = true; // Proyectar sombras
                headMeshes[key].receiveShadow = true; // Recibir sombras

                // Aseguramos suficiente espacio para los segmentos
                tailMeshes[key] = new THREE.InstancedMesh(tailGeo, new THREE.MeshPhongMaterial({color: 0x777777}), count * (params.segments + 1));
                tailMeshes[key].castShadow = true; // Proyectar sombras
                tailMeshes[key].receiveShadow = true; // Recibir sombras

                scene.add(headMeshes[key], tailMeshes[key]);
            });

            const keys = Object.keys(species);
            for (let layer = 0; layer < 2; layer++) {
                const isTop = (layer === 0);
                for (let i = 0; i < SIZE; i++) {
                    for (let j = 0; j < SIZE; j++) {
                        const type = keys[Math.floor(Math.random() * keys.length)];
                        const sParams = species[type];
                        
                        const x = (i - SIZE/2) * params.spacing;
                        const z = (j - SIZE/2) * params.spacing;
                        const y = isTop ? params.layerGap : -params.layerGap;

                        const lipid = { type, isTop, points: [], instanceIdx: i * SIZE + j + (layer * SIZE * SIZE) };
                        for(let s = 0; s <= params.segments; s++) {
                            const py = isTop ? y - (s * sParams.boneLength) : y + (s * sParams.boneLength);
                            lipid.points.push({
                                pos: new THREE.Vector3(x, py, z),
                                old: new THREE.Vector3(x, py, z),                                protein: null, // Referencia a la prote√≠na si este l√≠pido es parte de una

                                origin: new THREE.Vector3(x, py, z),
                                acc: new THREE.Vector3(0, 0, 0)
                            });
                        }
                        lipids.push(lipid);
                    }
                }
            }
            updateStatsDOM(); // Inicializar UI de stats
            updateElementCount(); // Inicializar contador de elementos
        }

        // --- UPDATE STATS DOM ---
        function updateStatsDOM() {
            const container = document.getElementById('stats-content');
            container.innerHTML = '';
            Object.keys(species).forEach(key => {
                const div = document.createElement('div');
                // Usamos colores hex para el CSS
                const colorHex = '#' + species[key].color.toString(16).padStart(6, '0');
                div.innerHTML = `
                    <div style="display:flex; justify-content:space-between;">
                        <span style="color:${colorHex}; font-size:11px; font-weight:bold;">${key}</span>
                    </div>
                    <div class="bar-container">
                        <div id="bar-${key.replace(/\s/g, '-')}" class="bar" style="background-color:${colorHex}; width: 0%"></div>
                    </div>`;
                container.appendChild(div);
            });
        }

        const mouseWorld = new THREE.Vector3(0, 0, 0);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // --- CURSOR DIN√ÅMICO SEG√öN POSICI√ìN ---
            if (selectedElementType === 'none') {
                renderer.domElement.style.cursor = 'default';
                return;
            }

            // Calcular posici√≥n del rat√≥n en el mundo
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const hoverPos = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, hoverPos);

            if (hoverPos) {
                const distFromCenter = Math.sqrt(hoverPos.x * hoverPos.x + hoverPos.z * hoverPos.z);

                if (distFromCenter <= MEMBRANE_RADIUS) {
                    renderer.domElement.style.cursor = 'crosshair'; // Dentro - modo colocaci√≥n
                    membraneBorder.material.opacity = 0.35; // Resaltar borde
                } else {
                    renderer.domElement.style.cursor = 'grab'; // Fuera - modo navegaci√≥n
                    membraneBorder.material.opacity = 0.2; // Borde normal
                }
            }
        });

        // --- SISTEMA DE CLICKS PARA COLOCAR ELEMENTOS ---
        window.addEventListener('click', (e) => {
            // Detectar si hizo click en UI
            const clickedUI = e.target.closest('#elements-panel, #stats-panel, .lil-gui, #ui-overlay');
            if (clickedUI) return;

            // Si no hay elemento seleccionado, permitir navegaci√≥n
            if (selectedElementType === 'none') return;

            // Raycast para encontrar posici√≥n en la membrana
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const clickPos = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, clickPos);

            if (clickPos) {
                // Verificar si el click est√° dentro del √°rea de la membrana
                const distanceFromCenter = Math.sqrt(clickPos.x * clickPos.x + clickPos.z * clickPos.z);

                if (distanceFromCenter <= MEMBRANE_RADIUS) {
                    // Click dentro de la membrana - colocar elemento
                    const layer = camera.position.y > 0 ? 'top' : 'bottom';
                    createElement(selectedElementType, clickPos, layer);

                    // Feedback visual
                    membraneBorder.material.opacity = 0.4;
                    setTimeout(() => { membraneBorder.material.opacity = 0.2; }, 100);
                }
                // Si est√° fuera, no hacer nada (OrbitControls maneja la c√°mara)
            }
        });

        // Click derecho para eliminar elementos
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (selectedElementType === 'none') return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
                externalElements.map(el => el.mesh)
            );

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const element = externalElements.find(el => el.mesh === clickedMesh);
                if (element) {
                    removeElement(element);
                }
            }
        });

        // --- UI PARA SELECCIONAR ELEMENTOS ---
        document.querySelectorAll('.element-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.element-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedElementType = btn.getAttribute('data-type');

                // Mostrar/ocultar indicadores visuales seg√∫n selecci√≥n
                if (selectedElementType === 'none') {
                    // Modo navegaci√≥n: ocultar todos los indicadores
                    membraneBorder.visible = false;
                    mouseRing.visible = false;
                } else {
                    // Modo colocaci√≥n: mostrar indicadores
                    membraneBorder.visible = true;
                    mouseRing.visible = true;
                    membraneBorder.material.opacity = 0.25;
                }
            });
        });

        function physicsUpdate() {
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            raycaster.ray.intersectPlane(plane, mouseWorld);
            
            // Actualizar anillo visual
            mouseRing.position.copy(mouseWorld);
            mouseRing.material.color.set(params.attractionMode ? 0xff4444 : 0xffffff);

            // Resetear energ√≠a acumulada
            Object.keys(species).forEach(k => species[k].energy = 0);

            lipids.forEach((l, idx) => {
                const s = species[l.type];
                const head = l.points[0];

                // 1. Vibraci√≥n T√©rmica
                if(params.temperature > 0) {
                    head.acc.x += (Math.random() - 0.5) * params.temperature;
                    head.acc.y += (Math.random() - 0.5) * params.temperature;
                    head.acc.z += (Math.random() - 0.5) * params.temperature;
                }

                // 2. Din√°mica de Resorte (reducida cerca de prote√≠nas inm√≥viles)
                const targetY = l.isTop ? params.layerGap : -params.layerGap;
                head.acc.y += (targetY - head.pos.y) * s.stiffness;

                // Calcular factor de elasticidad basado en proximidad a prote√≠nas inm√≥viles
                let elasticityFactor = 1.0;
                externalElements.forEach(element => {
                    const def = elementTypes[element.type];
                    if (def.immobile) {
                        const distToProtein = head.pos.distanceTo(element.pos);
                        const influenceRadius = def.radius * 4.0;
                        if (distToProtein < influenceRadius) {
                            // Reducir elasticidad progresivamente cerca de la prote√≠na
                            const proximityFactor = distToProtein / influenceRadius;
                            elasticityFactor = Math.min(elasticityFactor, proximityFactor * 0.3);
                        }
                    }
                });

                head.acc.x += (head.origin.x - head.pos.x) * s.elasticity * elasticityFactor;
                head.acc.z += (head.origin.z - head.pos.z) * s.elasticity * elasticityFactor;

                // 3. Interacci√≥n Rat√≥n
                const dist = head.pos.distanceTo(mouseWorld);
                if(dist < params.mouseRadius) {
                    const dir = new THREE.Vector3().subVectors(head.pos, mouseWorld).normalize();
                    const forceMag = (1 - dist/params.mouseRadius) * params.mouseForce;

                    if (params.attractionMode) {
                        head.acc.sub(dir.multiplyScalar(forceMag));
                    } else {
                        head.acc.add(dir.multiplyScalar(forceMag));
                    }
                }

                // 4. Repulsi√≥n entre l√≠pidos vecinos (optimizado - solo cercanos)
                if (params.lipidRepulsion > 0) {
                    // Solo chequear l√≠pidos en un radio limitado para optimizaci√≥n
                    const checkRadius = 2.0;
                    lipids.forEach((other, otherIdx) => {
                        if (idx < otherIdx && l.isTop === other.isTop) { // idx < otherIdx evita chequeos duplicados
                            const otherHead = other.points[0].pos;
                            const diff = new THREE.Vector3().subVectors(head.pos, otherHead);
                            const distance = diff.length();

                            if (distance < checkRadius) {
                                const minDist = 0.82; // Distancia m√≠nima (casi pegadas)

                                if (distance < minDist && distance > 0.01) {
                                    const repulsionForce = ((minDist - distance) / minDist) * params.lipidRepulsion;
                                    const force = diff.normalize().multiplyScalar(repulsionForce);
                                    head.acc.add(force);
                                    other.points[0].acc.sub(force); // Aplicar fuerza opuesta al otro l√≠pido
                                }
                            }
                        }
                    });
                }

                // 5. Interacci√≥n con elementos externos (mejorado - mayor impacto)
                externalElements.forEach(element => {
                    const elemPos = element.pos;
                    const distToElem = head.pos.distanceTo(elemPos);
                    const def = elementTypes[element.type];

                    // Prote√≠nas transmembrana tienen mayor radio de interacci√≥n
                    const interactionMultiplier = def.strongInteraction ? 3.5 : 2.5;
                    const interactionRadius = def.radius * interactionMultiplier;

                    if (distToElem < interactionRadius) {
                        // PROTE√çNAS INM√ìVILES: Solo repulsi√≥n, sin atracci√≥n
                        if (def.immobile) {
                            // Repulsi√≥n muy fuerte - la prote√≠na empuja los l√≠pidos
                            const repelDir = new THREE.Vector3().subVectors(head.pos, elemPos);
                            repelDir.y = 0; // Solo lateral

                            // Radio de repulsi√≥n expandido para prote√≠nas inm√≥viles
                            const repulsionRadius = def.radius * 2.5;
                            if (distToElem < repulsionRadius) {
                                const baseRepulsion = 4.5; // Muy fuerte
                                const repelForce = (1 - distToElem / repulsionRadius) * baseRepulsion;
                                head.acc.add(repelDir.normalize().multiplyScalar(repelForce));
                            }
                        } else {
                            // PROTE√çNAS M√ìVILES: Comportamiento normal con atracci√≥n
                            const isAnchored = element.anchoredLipids.some(a => a.lipid === l);

                            if (isAnchored) {
                                // Fuerza de atracci√≥n hacia la prote√≠na
                                const attractDir = new THREE.Vector3().subVectors(elemPos, head.pos);
                                attractDir.y = 0; // Solo lateral
                                const attractStrength = def.strongInteraction ? 0.08 : 0.05;
                                const attractForce = (distToElem / interactionRadius) * attractStrength;
                                head.acc.add(attractDir.normalize().multiplyScalar(attractForce));
                            } else if (distToElem < def.radius * 2.0) {
                                // Repulsi√≥n si est√° muy cerca pero no anclado
                                const repelDir = new THREE.Vector3().subVectors(head.pos, elemPos);
                                repelDir.y = 0; // Solo lateral
                                const baseRepulsion = def.strongInteraction ? 3.5 : 0.4;
                                const repelForce = (1 - distToElem / (def.radius * 2.0)) * baseRepulsion;
                                head.acc.add(repelDir.normalize().multiplyScalar(repelForce));
                            }
                        }
                    }
                });

                // 4. Integraci√≥n Verlet + C√°lculo de Energ√≠a
                l.points.forEach((p, idx) => {
                    if(idx > 0) p.acc.y += s.gravity * (l.isTop ? -1 : 1);
                    
                    const vel = new THREE.Vector3().subVectors(p.pos, p.old);
                    
                    // Sumar energ√≠a cin√©tica para las estad√≠sticas
                    s.energy += vel.length();

                    vel.multiplyScalar(params.drag);
                    p.old.copy(p.pos); 
                    p.pos.add(vel).add(p.acc); 
                    p.acc.set(0, 0, 0);
                });

                // 5. Restricciones de Cola (L√≥gica de Index2)
                for(let n = 0; n < 3; n++) {
                    for(let i = 0; i < l.points.length - 1; i++) {
                        const p1 = l.points[i], p2 = l.points[i+1];
                        const diff = new THREE.Vector3().subVectors(p2.pos, p1.pos);
                        const currentLen = diff.length();
                        const err = (currentLen - s.boneLength) / currentLen;
                        const corr = diff.multiplyScalar(err * 0.5);
                        
                        if(i === 0) p2.pos.sub(corr.multiplyScalar(1.8)); // Cabeza fija, cola se mueve m√°s
                        else { p1.pos.add(corr); p2.pos.sub(corr); }
                    }
                }
            });

            // Actualizar Barras de UI
            Object.keys(species).forEach(k => {
                const barId = `bar-${k.replace(/\s/g, '-')}`;
                const el = document.getElementById(barId);
                if(el) {
                    // Factor de escala visual para que la barra se vea bien
                    const width = Math.min(species[k].energy * 0.5, 100);
                    el.style.width = width + '%';
                }
            });

            // --- F√çSICA DE ELEMENTOS EXTERNOS ---
            externalElements.forEach(element => {
                const def = elementTypes[element.type];

                // Si es inm√≥vil, solo actualizar posici√≥n del mesh y saltar f√≠sica
                if (def.immobile) {
                    element.mesh.position.copy(element.pos);
                    return;
                }

                // 1. Calcular posici√≥n promedio de l√≠pidos anclados (mejorado)
                if (element.anchoredLipids.length > 0) {
                    const avgPos = new THREE.Vector3(0, 0, 0);
                    let totalWeight = 0;

                    element.anchoredLipids.forEach(anchor => {
                        const lipidPos = anchor.lipid.points[0].pos;
                        const distance = lipidPos.distanceTo(element.pos);
                        // Peso basado en distancia - l√≠pidos m√°s cercanos tienen m√°s influencia
                        const weight = 1.0 / (distance + 0.5);
                        avgPos.add(lipidPos.clone().multiplyScalar(weight));
                        totalWeight += weight;
                    });

                    if (totalWeight > 0) {
                        avgPos.divideScalar(totalWeight);

                        // Aplicar fuerza hacia posici√≥n promedio (anclaje el√°stico m√°s fuerte)
                        const anchorForce = new THREE.Vector3().subVectors(avgPos, element.pos);
                        anchorForce.y = 0; // Solo movimiento lateral
                        element.acc.add(anchorForce.multiplyScalar(0.25)); // Aumentado de 0.1 a 0.25
                    }

                    // Aplicar fuerzas de los l√≠pidos anclados individualmente
                    element.anchoredLipids.forEach(anchor => {
                        const lipid = anchor.lipid;
                        const lipidVel = new THREE.Vector3().subVectors(
                            lipid.points[0].pos,
                            lipid.points[0].old
                        );
                        // El elemento hereda parte del movimiento de los l√≠pidos
                        element.acc.add(lipidVel.multiplyScalar(0.05));
                    });
                }

                // 2. Inercia adicional por masa
                const massEffect = 1.0 - (def.mass * 0.05);

                // 3. Fricci√≥n con la membrana
                const vel = new THREE.Vector3().subVectors(element.pos, element.old);
                vel.multiplyScalar(0.88 * massEffect); // Fricci√≥n variable seg√∫n masa

                // 4. Integraci√≥n Verlet
                element.old.copy(element.pos);
                element.pos.add(vel).add(element.acc);
                element.acc.set(0, 0, 0);

                // 5. Actualizar posici√≥n del mesh
                element.mesh.position.copy(element.pos);

                // 6. Rotaci√≥n suave basada en movimiento (nuevo - para realismo)
                if (vel.length() > 0.01) {
                    const currentRotation = element.mesh.rotation.y;
                    const targetRotation = Math.atan2(vel.x, vel.z);
                    element.mesh.rotation.y = THREE.MathUtils.lerp(currentRotation, targetRotation, 0.1);
                }

                // 5. F√≠sica de cadenas de glicanos
                if (element.glycanChains.length > 0) {
                    element.glycanChains.forEach(chain => {
                        chain.points.forEach((p, idx) => {
                            if (idx === 0) {
                                // Primer punto anclado al elemento
                                const localPos = chain.points[0].pos.clone();
                                p.pos.copy(element.pos).add(localPos);
                                p.old.copy(p.pos);
                            } else {
                                // Gravedad ligera hacia arriba (flotaci√≥n)
                                p.acc.y += 0.01;

                                // Vibraci√≥n t√©rmica
                                if (params.temperature > 0) {
                                    p.acc.x += (Math.random() - 0.5) * params.temperature * 2;
                                    p.acc.z += (Math.random() - 0.5) * params.temperature * 2;
                                }

                                // Integraci√≥n
                                const chainVel = new THREE.Vector3().subVectors(p.pos, p.old);
                                chainVel.multiplyScalar(0.9);
                                p.old.copy(p.pos);
                                p.pos.add(chainVel).add(p.acc);
                                p.acc.set(0, 0, 0);
                            }
                        });

                        // Restricciones de distancia entre segmentos
                        for (let iter = 0; iter < 2; iter++) {
                            for (let i = 0; i < chain.points.length - 1; i++) {
                                const p1 = chain.points[i];
                                const p2 = chain.points[i + 1];
                                const diff = new THREE.Vector3().subVectors(p2.pos, p1.pos);
                                const dist = diff.length();
                                const targetDist = 0.6;
                                const error = (dist - targetDist) / dist;
                                const correction = diff.multiplyScalar(error * 0.5);

                                if (i === 0) {
                                    p2.pos.sub(correction);
                                } else {
                                    p1.pos.add(correction);
                                    p2.pos.sub(correction);
                                }
                            }
                        }
                    });
                }

            });
        }

        const dummy = new THREE.Object3D();
        const tailCounters = {};

        // Geometr√≠a y material para glicanos
        let glycanLineMaterial, glycanSphereGeo, glycanSphereMat;

        function render() {
            physicsUpdate();
            controls.update(); // Actualizar OrbitControls

            Object.keys(species).forEach(k => tailCounters[k] = 0);

            lipids.forEach((l) => {
                const hMesh = headMeshes[l.type];
                const tMesh = tailMeshes[l.type];

                // Render Cabeza
                dummy.position.copy(l.points[0].pos);
                dummy.rotation.set(0,0,0);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                hMesh.setMatrixAt(l.instanceIdx, dummy.matrix);

                // Render Cola (Estilo Index2)
                for(let s = 0; s < params.segments; s++) {
                    const p1 = l.points[s].pos, p2 = l.points[s+1].pos;
                    dummy.position.copy(p1).add(p2).multiplyScalar(0.5);
                    dummy.lookAt(p2);
                    // Escala el cilindro para conectar los puntos perfectamente (Look de Index2)
                    dummy.scale.set(1, 1, p1.distanceTo(p2));
                    dummy.updateMatrix();
                    tMesh.setMatrixAt(tailCounters[l.type]++, dummy.matrix);
                }
            });

            Object.keys(species).forEach(k => {
                headMeshes[k].instanceMatrix.needsUpdate = true;
                tailMeshes[k].instanceMatrix.needsUpdate = true;
            });

            // Renderizar cadenas de glicanos
            externalElements.forEach(element => {
                element.glycanChains.forEach(chain => {
                    // Eliminar l√≠neas anteriores si existen
                    if (chain.line) {
                        scene.remove(chain.line);
                        chain.line.geometry.dispose();
                    }
                    if (chain.spheres) {
                        chain.spheres.forEach(s => {
                            scene.remove(s);
                            s.geometry.dispose();
                            s.material.dispose();
                        });
                    }

                    // Crear l√≠neas conectando los puntos
                    const points = chain.points.map(p => p.pos);
                    const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                    if (!glycanLineMaterial) {
                        glycanLineMaterial = new THREE.LineBasicMaterial({ color: 0x88ff88, linewidth: 2 });
                    }
                    chain.line = new THREE.Line(lineGeo, glycanLineMaterial);
                    scene.add(chain.line);

                    // Crear esferas en cada punto
                    chain.spheres = [];
                    if (!glycanSphereGeo) {
                        glycanSphereGeo = new THREE.SphereGeometry(0.15, 8, 6);
                        glycanSphereMat = new THREE.MeshPhongMaterial({ color: 0x88ff88 });
                    }
                    chain.points.forEach(p => {
                        const sphere = new THREE.Mesh(glycanSphereGeo, glycanSphereMat);
                        sphere.position.copy(p.pos);
                        scene.add(sphere);
                        chain.spheres.push(sphere);
                    });
                });
            });

            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        // --- ILUMINACI√ìN Y SOMBRAS ---
        scene.add(new THREE.AmbientLight(0x444444, 1.0)); // Luz ambiental para iluminaci√≥n base

        const light = new THREE.DirectionalLight(0xffffff, 2.5); // Luz direccional m√°s intensa
        light.position.set(10, 20, 10);
        light.castShadow = true; // Proyectar sombras

        // Configuraci√≥n de sombras de alta calidad
        light.shadow.mapSize.width = 2048; // Mayor resoluci√≥n para sombras m√°s n√≠tidas
        light.shadow.mapSize.height = 2048;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 50;
        light.shadow.camera.left = -25;
        light.shadow.camera.right = 25;
        light.shadow.camera.top = 25;
        light.shadow.camera.bottom = -25;
        light.shadow.bias = -0.0001; // Reducir artefactos de sombra

        scene.add(light);

        // Plano de fondo para recibir sombras (simula ambient occlusion)
        const planeGeo = new THREE.PlaneGeometry(60, 60);
        const planeMat = new THREE.ShadowMaterial({ opacity: 0.3 }); // Material que solo muestra sombras
        const groundPlane = new THREE.Mesh(planeGeo, planeMat);
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.position.y = -5; // Debajo de la membrana
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);

        // Funciones de C√°mara (Ahora compatibles con OrbitControls)
        const setCam = (x,y,z) => { 
            camera.position.set(x,y,z); 
            controls.target.set(0,0,0);
            controls.update();
        };
        document.getElementById('view-p').onclick = () => setCam(22, 18, 22);
        document.getElementById('view-f').onclick = () => setCam(0, 0, 40);
        document.getElementById('view-l').onclick = () => setCam(40, 0, 0);

        init();
        setCam(22, 18, 22);
        render();
    </script>
</body>
</html>